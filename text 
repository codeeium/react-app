Hereâ€™s a clean and formatted version of your list, item by item:

1. **Primitive Types** (string, number, boolean):
   Basic types like `string`, `number`, and `boolean` represent the fundamental building blocks of TypeScript.

2. **Array State**:
   Represents a collection of values of a specific type, e.g., `number[]` or `Array<string>`.

3. **Object State**:
   Represents a structured collection of key-value pairs, typically defined with type annotations for each property.

4. **Union Types**:
   Allows a variable to hold one of several types, defined using the `|` operator, e.g., `string | number`.

5. **Nullable or Undefined State**:
   Specifies values that can either be of a certain type or `null`/`undefined`, e.g., `string | null` or `number | undefined`.

6. **Generic State**:
   Enables types to be dynamic and reusable by using type parameters, e.g., `Array<T>` or `Promise<T>`.

Let me know if you need further modifications!



Here's how to handle both the **current** and **updated values** for each type of state in React with TypeScript:

---

### 1. **Primitive Types (string, number, boolean):**
```tsx
import React, { useState } from 'react';

const App: React.FC = () => {
    const [count, setCount] = useState<number>(0);

    const increment = () => {
        console.log('Current Count:', count);
        setCount(prevCount => {
            console.log('Updated Count:', prevCount + 1);
            return prevCount + 1;
        });
    };

    return (
        <div>
            <p>Count: {count}</p>
            <button onClick={increment}>Increment</button>
        </div>
    );
};

export default App;
```

---

### 2. **Array State:**
```tsx
import React, { useState } from 'react';

const App: React.FC = () => {
    const [items, setItems] = useState<string[]>([]);

    const addItem = () => {
        console.log('Current Items:', items);
        setItems(prevItems => {
            const updatedItems = [...prevItems, `Item ${prevItems.length + 1}`];
            console.log('Updated Items:', updatedItems);
            return updatedItems;
        });
    };

    return (
        <div>
            <ul>
                {items.map((item, index) => (
                    <li key={index}>{item}</li>
                ))}
            </ul>
            <button onClick={addItem}>Add Item</button>
        </div>
    );
};

export default App;
```

---

### 3. **Object State:**
```tsx
import React, { useState } from 'react';

type User = {
    name: string;
    age: number;
};

const App: React.FC = () => {
    const [user, setUser] = useState<User>({ name: 'John', age: 25 });

    const updateUser = () => {
        console.log('Current User:', user);
        setUser(prevUser => {
            const updatedUser = { ...prevUser, name: 'Jane', age: 30 };
            console.log('Updated User:', updatedUser);
            return updatedUser;
        });
    };

    return (
        <div>
            <p>Name: {user.name}</p>
            <p>Age: {user.age}</p>
            <button onClick={updateUser}>Update User</button>
        </div>
    );
};

export default App;
```

---

### 4. **Union Types:**
```tsx
import React, { useState } from 'react';

const App: React.FC = () => {
    const [state, setState] = useState<string | number>('Hello');

    const toggleState = () => {
        console.log('Current State:', state);
        setState(prevState => {
            const updatedState = typeof prevState === 'string' ? 42 : 'Hello';
            console.log('Updated State:', updatedState);
            return updatedState;
        });
    };

    return (
        <div>
            <p>State: {state}</p>
            <button onClick={toggleState}>Toggle State</button>
        </div>
    );
};

export default App;
```

---

### 5. **Nullable or Undefined State:**
```tsx
import React, { useState } from 'react';

const App: React.FC = () => {
    const [data, setData] = useState<string | null>(null);

    const loadData = () => {
        console.log('Current Data:', data);
        setData(() => {
            const updatedData = 'Loaded Data';
            console.log('Updated Data:', updatedData);
            return updatedData;
        });
    };

    const clearData = () => {
        console.log('Current Data:', data);
        setData(() => {
            console.log('Updated Data: null');
            return null;
        });
    };

    return (
        <div>
            <p>Data: {data ?? 'No Data Available'}</p>
            <button onClick={loadData}>Load Data</button>
            <button onClick={clearData}>Clear Data</button>
        </div>
    );
};

export default App;
```

---

### 6. **Generic State:**
```tsx
import React, { useState } from 'react';

type Item<T> = {
    id: number;
    value: T;
};

const App: React.FC = () => {
    const [items, setItems] = useState<Item<string>[]>([]);

    const addItem = () => {
        console.log('Current Items:', items);
        setItems(prevItems => {
            const updatedItems = [
                ...prevItems,
                { id: prevItems.length + 1, value: `Item ${prevItems.length + 1}` }
            ];
            console.log('Updated Items:', updatedItems);
            return updatedItems;
        });
    };

    return (
        <div>
            <ul>
                {items.map(item => (
                    <li key={item.id}>{item.value}</li>
                ))}
            </ul>
            <button onClick={addItem}>Add Item</button>
        </div>
    );
};

export default App;
```

---

### Summary:
- Use `console.log` or other debugging techniques inside the state update function to track the **current** and **updated** state values.
- React's `useState` supports a variety of types, allowing for flexibility in managing state in complex applications.